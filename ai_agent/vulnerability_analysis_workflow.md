# 现实世界二进制漏洞挖掘工作流：以 /bin/ls 为例

## 核心理念：从“寻找漏洞”到“实践流程”

直接在像 `/bin/ls` 这样经过数十年考验的核心系统工具中寻找漏洞，成功率极低。因此，我们的目标应该从“找到一个0-day”转变为“**通过分析一个高安全性的目标，来实践和掌握一套专业的漏洞挖掘流程**”。

本指南将这套流程分解为四个主要阶段，并阐述在每个阶段中，`Rizin` 和 `angr` 等工具如何发挥其独特作用。

---

## 第一阶段：侦察与信息收集 (Reconnaissance)

在深入代码之前，必须先了解我们的目标。

*   **目标**：确定二进制文件的基本属性、架构、依赖库以及开启了哪些安全保护机制。
*   **核心工具**：`rz-bin` (Rizin 工具套件), `checksec`

### 操作步骤

1.  **查看文件基础信息**：
    使用 `rabin2 -I` 来获取文件类型、架构、大小端等信息。
    ```bash
rabin2 -I /bin/ls
    ```
    **关键信息**：`arch` (e.g., x86), `bits` (e.g., 64), `pie` (Position-Independent Executable)。`pie` 为 `true` 意味着地址空间布局随机化 (ASLR) 会生效。

2.  **检查安全缓解��施**：
    使用 `checksec` (或 `rabin2 -z`) 来查看二进制文件编译时开启了哪些安全保护。
    ```bash
checksec /bin/ls
    ```
    **输出解读**：
    *   `Canary`: **found** - 开启了栈Canary保护，用于防御经典的缓冲区溢出。
    *   `NX`: **enabled** - 开启了“不可执行”保护，意味着栈和堆上的数据段不能被当作代码执行，直接杜绝了简单的 shellcode 注入。
    *   `PIE`: **enabled** - 地址随机化，使得攻击者难以预测代码和数据的内存地址。
    *   `RELRO`: **Full** - “重定位表只读”。这使得攻击者无法轻易地通过覆写 GOT (Global Offset Table) 表来劫持函数调用。

**阶段结论**：我们面对的是一个“全副武装”的现代二进制文件。任何漏洞利用都必须考虑绕过这些复杂的保护机制。

---

## 第二阶段：静态分析 (Static Analysis)

在这一阶段，我们深入代码，寻找设计上或实现上可能存在的“坏味道”(Code Smell)。

*   **目标**：识别危险函数调用、理解核心逻辑、定位处理复杂输入的代码区域。
*   **核心工具**：`Rizin`, `Ghidra`

### 操作步骤

1.  **加载并深度分析**：
    使用 `r2 -A` (或 `r2 -AA`) 加载并自动分析二进制文件。
    ```bash
r2 -A /bin/ls
    ```

2.  **寻找已知的危险函数**：
    虽然现代程序对 `strcpy`, `sprintf` 等函数有安全包装 (`_chk` 版本)，但它们的出现点仍然是重点怀疑对象。
    ```bash
# 在 r2 命令行中
[0x0000555555555555]> afl | grep -E "strcpy|strcat|sprintf"
    ```

3.  **定位并理解核心逻辑**：
    `/bin/ls` 的核心功能是解析命令行参数并格式化输出目录内容。最可能出问题的部分在于**解析逻辑**，尤其是处理不常见或畸形输入的代码。
    *   **分析 `main` 函数**：使用 `pdf @ main` 查看 `main` 函数的汇编，了解程序的主流程。
    *   **跟踪参数解析**：`main` 函数通常会调用 `getopt_long` 或类似函数来解析 `argv`。跟踪这些函数的调用和返回值处理，是理解程序行为的关键。
    *   **寻找复杂循环**：注意处理文件名、路径或其他字符串的循环。这些地方是可能出现“差一错误”(Off-by-one) 或整数溢出的高发区。把这些可疑的函数地址记录下来。

**阶段结论**：静态分析不太可能直接找到一个明显的漏洞。它的核心价值在于**缩小怀疑范围**，为下一阶段的动态分析和符号执行提供精确的目标。

---

## 第三阶段：动态分析与模糊测试 (Dynamic Analysis & Fuzzing)

静态分���给了我们“地图”，现在我们需要用真实数据去“踩点”，尝试触发程序的异常行为。

*   **目标**：通过提供非预期的、畸形的输入，使程序崩溃或进入异常状态。
*   **核心工具**：`AFL++` (Fuzzer), `gdb` (Debugger)

### 操作步骤

1.  **模糊测试 (Fuzzing)**：
    这是现代漏洞挖掘最高效的手段之一。AFL++ 这类覆盖率指导的 Fuzzer 会智能地变异输入，以探索程序更多、更深的代码路径。
    *   **原理**：为 `/bin/ls` 提供一个合法的初始输入（例如，一个包含各种文件类型的目录作为测试用例），AFL++ 会对输入进行成千上万次变异，然后执行 `/bin/ls`。如果某个输入导致程序崩溃（如段错误），这个输入就会被记录下来，成为我们的重点分析对象。
    *   **挑战**：对 `/bin/ls` 这种与文件系统强交互的程序进行 Fuzzing 需要精心设计环境，但这绝对是值得投入精力的方向。

2.  **手动调试**：
    使用 `gdb` 附加到 `/bin/ls` 进程，或直接用 `gdb --args ls ...` 启动。在你静态分析阶段找到的可疑函数（如 `0x401234`）下断点，然后手动构造一些边界输入（如超长文件名、含特殊字符的参数）来观察程序的内部状态。

**阶段结论**：如果 Fuzzing 找到了一个能导致崩溃的输入，你就已经成功一大半。接下来的任务是分析这个崩溃，确定其能否被利用。如果 Fuzzing 没有结果，静态分析中标记的可疑函数依然是我们的重点。

---

## 第四阶段：符号执行 (Symbolic Execution)

**`angr` 在此登场。** 它不是用来扫描整个 `/bin/ls` 的“巡航导弹”，而是用来对付特定目标的“精确制导炸弹”。

*   **目标**：在通过前序分析定位到**某个具体、小而复杂的函数**后，用 `angr` 彻底探索该函数的所有执行路径，寻找能够触发漏洞（如控制指令指针 `rip`）的精确输入。
*   **核心工具**：`angr`

### 实践场景

**假设**：我们在静态分析时发现一个名为 `parse_special_format` 的函数（地址 `0x401234`），它负责解析一种特殊格式的字符串。我们怀疑当输入字符串的格式满足某种复杂条件时，会触发缓冲区溢出。

### 使用 `angr` 的步骤

1.  **编写 `angr` 脚本**：
    我们的目标不是从 `main` 函数开始（这会导致状态爆炸），而是直接“切割”出目标函数进行分析。

    ```python
import angr
import claripy

# 1. 加载二进制文件��关闭库的自动加载以提高速度
proj = angr.Project('/bin/ls', auto_load_libs=False)

# 2. 定义分析目标和符号输入
TARGET_FUNC_ADDR = 0x401234  # 我们怀疑的目标函数地址

# 创建一个符号化的比特向量，作为函数的输入字符串
# 假设我们猜测溢出与一个100字节的缓冲区有关
BUFFER_SIZE = 100
symbolic_input_str = claripy.BVS('input_str', BUFFER_SIZE * 8)

# 3. 创建一个专门用于分析此函数的状态
# 我们不使用 entry_state()，而是使用 call_state()，这更高效
# 这会创建一个模拟函数调用的状态

# 在模拟内存中为我们的符号字符串分配一个地址
# 这个地址可以是任意未被使用的区域
input_addr = 0xDEADBEEF00

state = proj.factory.call_state(
        TARGET_FUNC_ADDR,
        input_addr, # 第一个参数 (char *)
        add_options={angr.options.LAZY_SOLVES} # 优化选项
    )

# 将符号字符串存储到我们分配的内存地址中
state.memory.store(input_addr, symbolic_input_str)

# 4. 创建并配置 Simulation Manager
simgr = proj.factory.simulation_manager(state)

# 5. 定义探索目标：找到一个可以控制指令指针 (rip) 的路径
# 当 rip 寄存器的值是一个符号变量时，意味着我们可以通过输入来控制它
print("Starting symbolic execution...")
simgr.explore(find=lambda s: s.regs.rip.symbolic)
print("Exploration finished.")

# 6. 分析结果
if simgr.found:
        found_state = simgr.found[0]
        print("\n[+] Vulnerable path found!")

        # 求解能够触发此路径的具体输入
        crashing_input = found_state.solver.eval(symbolic_input_str, cast_to=bytes)
        print(f"[*] Crashing input: {crashing_input.hex()}")

        # 进一步分析 rip 被什么值所控制
        controlled_rip = found_state.regs.rip
        print(f"[*] RIP is controlled by: {controlled_rip}")

        # 检查输入字符串的哪一部分控制了 RIP
        for i in range(BUFFER_SIZE):
            if found_state.solver.eval(symbolic_input_str.get_byte(i)) in found_state.solver.eval(controlled_rip, cast_to=bytes):
                 print(f"[*] Byte at offset {i} of input influences RIP.")

else:
        print("\n[-] No vulnerable path found in this function with the given constraints.")

    ```

**阶段结论**：`angr` 成功地为我们找到了一个能够精确控制 `rip` 的输入字符串。这为我们后续编写漏洞利用代码（如 ROP 链）提供了决定性的第一步。

## 最终总结

漏洞挖掘是一个层层递进���系统工程，而不是单一工具的独角戏。

1.  **始于广度**：从 `rabin2` 和 `checksec` 开始，对目标进行宏观侦察。
2.  **精于静态**：用 `Rizin` 或 `Ghidra` 深入代码，识别出高风险的“可疑区域”。
3.  **验证于动态**：用 Fuzzer 或 `gdb` 对可疑区域进行冲击，尝试触发异常。
4.  **终结于符号执行**：当面对小范围、高复杂度的路径问题时，动用 `angr` 这把“手术刀”，找到通往漏洞的精确路径和输入。

熟练掌握这一套从宏观到微观的工作流，远比仅仅学会某个工具的零散命令要重要得多。

```
