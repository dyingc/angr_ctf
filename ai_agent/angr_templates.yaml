templates:
  # 1) Path search (merges: find_path + avoid)
  path_search: |
    #!/usr/bin/env python3

    import angr
    import claripy
    import sys

    # ============================================================================
    # CONFIGURATION SECTION
    # ============================================================================

    binary_path = r"{binary_path}"  # Path to target binary

    # Finding TARGET addresses (where you want to reach):
    # 1. Use a disassembler (IDA, Ghidra, radare2, objdump)
    # 2. Look for success indicators:
    #    - String references: "Success", "Good job", "Flag:", etc.
    #    - Function calls: puts("Win!"), printf("Correct")
    #    - Return values: return 0 (success) vs return 1 (failure)

    # Finding AVOID addresses (paths to skip):
    # 1. Look for failure indicators:
    #    - String references: "Try again", "Wrong", "Invalid", "Access denied"
    #    - Function calls: exit(1), puts("Failed"), abort()
    #    - Error handling: perror(), fprintf(stderr, ...)
    # 2. Identify expensive/infinite loops:
    #    - Sleep/delay functions: sleep(), usleep()
    #    - Decoy functions with long computations
    #    - Anti-debugging checks: ptrace(), signal handlers
    # 3. Common avoid patterns:
    #    - The address right before exit(1) calls
    #    - Beginning of error handling blocks
    #    - Jump targets that lead to failure messages

    # Option 1: Direct address targeting
    find_addr = 0x401234          # Address where success path begins
    avoid_addrs = [0x401000]      # List of failure addresses

    # Option 2: Output-based targeting (more flexible)
    # find_addr = lambda s: b"SUCCESS" in s.posix.dumps(1)  # stdout contains SUCCESS
    # avoid_addrs = lambda s: b"FAIL" in s.posix.dumps(1)   # stdout contains FAIL

    # ============================================================================
    # SYMBOLIC INPUT CONFIGURATION
    # ============================================================================

    # When to use different input methods:

    # Method 1: Direct stdin (simple, for reading with scanf/gets/fgets)
    # Best for: Programs that read input once at start
    use_direct_stdin = False

    # Method 2: Symbolic variables with SimPackets (more control)
    # Best for: Complex input constraints, multiple inputs, specific formats
    use_symbolic_packets = True

    # Method 3: Arguments/environment (for argv/argc programs)
    # Best for: Command-line argument processing
    use_argv = False

    # ============================================================================
    # MAIN EXECUTION
    # ============================================================================

    def main():
        # Load binary (auto_load_libs=False speeds up analysis for CTF binaries)
        p = angr.Project(binary_path, auto_load_libs=False)

        # Choose entry point
        start = p.entry  # Program entry point
        # start = 0x401000  # Or specific address to start from

        # common add toptions
        add_options = {
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS
        }

        # Create initial state based on input method
        if use_symbolic_packets:
            # Create symbolic input with constraints
            input_length = 32  # Adjust based on program expectations
            sym_input = claripy.BVS("input", input_length * 8)  # Bits = bytes * 8

            # Method 2a: Using SimPackets for structured input - DO NOT use SimFileStream or SimFile for the `stdin`
            sym_packets = angr.SimPackets(name='stdio', content=[sym_input])
            s = p.factory.entry_state(
                addr=start,
                stdin=sym_packets,  # Must set symbolic packets here when creating the state; don't assign them to stdin afterward.
                add_options=add_options
            )

            # Add constraints for printable ASCII (need to adjust based on real requirements)
            for i in range(input_length):
                byte = sym_input.get_byte(i)
                s.solver.add(byte >= 0x20)  # Space
                s.solver.add(byte <= 0x7e)  # Tilde
                # For alphanumeric only:
                # s.solver.add(claripy.Or(
                #     claripy.And(byte >= ord('a'), byte <= ord('z')),
                #     claripy.And(byte >= ord('A'), byte <= ord('Z')),
                #     claripy.And(byte >= ord('0'), byte <= ord('9'))
                # ))

        elif use_direct_stdin:
            # Method 1: Simple stdin without pre-constraints
            s = p.factory.entry_state(addr=start, add_options=add_options)
            # Input will be symbolic when program reads stdin

        elif use_argv:
            # Method 3: Command-line arguments
            argv_sym = [binary_path]  # argv[0] is program name
            for i in range(1, 3):  # Add symbolic argv[1], argv[2], etc.
                arg = claripy.BVS(f"argv_{i}", 8 * 16)  # 16 bytes per arg
                argv_sym.append(arg)
            s = p.factory.entry_state(addr=start, args=argv_sym, add_options=add_options)

        else:
            # Basic state without special input handling
            s = p.factory.entry_state(addr=start, add_options=add_options)

        # Create simulation manager
        sm = p.factory.simulation_manager(s)

        # ============================================================================
        # PATH EXPLORATION
        # ============================================================================

        print(f"Starting symbolic execution...")
        print(f"Target: {hex(find_addr) if isinstance(find_addr, int) else 'lambda function'}")
        print(f"Avoiding: {[hex(a) for a in avoid_addrs] if isinstance(avoid_addrs, list) else 'lambda function'}")

        # Explore with optional parameters
        sm.explore(
            find=find_addr,
            avoid=avoid_addrs,
            # Optional parameters:
            # n=100,              # Max number of states to find
            # num_find=1,         # Stop after finding this many
            # avoid_priority=True # Prioritize avoiding over finding
        )

        # ============================================================================
        # RESULT EXTRACTION
        # ============================================================================

        if sm.found:
            print(f"\n✅ SUCCESS! Found {len(sm.found)} solution(s)")

            for i, st in enumerate(sm.found):
                print(f"\n--- Solution {i+1} ---")

                # Check if constraints are satisfiable
                if st.solver.satisfiable():
                    # Extract stdin input. This was actually read from stdin during execution which may include
                    # partial reads or multiple reads. It reflects the actual I/O operations that occurred
                    try:
                        stdin_data = st.posix.dumps(sys.stdin.fileno())
                        print(f"stdin: {stdin_data}")
                        # For printable strings:
                        # print(f"stdin (ascii): {stdin_data.decode('ascii', errors='ignore')}")
                    except Exception as e:
                        print(f"Could not extract stdin: {e}")

                    # Extract stdout output
                    try:
                        stdout_data = st.posix.dumps(sys.stdout.fileno())
                        if stdout_data:
                            print(f"stdout: {stdout_data}")
                    except:
                        pass

                    # If using symbolic variables, extract their values
                    # This is the full input buffer you created and may include bytes that were never actually read by the program
                    if use_symbolic_packets:
                        try:
                            concrete_input = st.solver.eval(sym_input, cast_to=bytes)
                            print(f"Symbolic input value: {concrete_input}")
                            print(f"As string: {concrete_input.decode('ascii', errors='ignore')}")
                        except:
                            pass

                    # Extract register values if needed
                    # print(f"eax: {st.regs.eax}")
                    # print(f"rdi: {st.regs.rdi}")  # x64

                    # Extract memory values if needed
                    # mem_val = st.memory.load(0x404000, 4)  # Read 4 bytes at address
                    # print(f"Memory at 0x404000: {st.solver.eval(mem_val, cast_to=bytes)}")

                    print(f"Final address reached: {hex(st.addr)}")
                else:
                    print(f"Solution {i+1} has unsatisfiable constraints")

        else:
            print("\n❌ No solution found")
            print(f"Deadended states: {len(sm.deadended)}")
            print(f"Active states: {len(sm.active)}")
            print(f"Avoided states: {len(sm.avoid)}")

            # Debug information
            if sm.deadended:
                print("\nDeadended states (first 3):")
                for st in sm.deadended[:3]:
                    print(f"  - Stopped at: {hex(st.addr)}")
                    # Check why it deadended
                    if st.addr == 0:
                        print("    (Likely segfault or exit)")

            if sm.active:
                print("\nActive states still exploring (first 3):")
                for st in sm.active[:3]:
                    print(f"  - Currently at: {hex(st.addr)}")

    # ============================================================================
    # COMMON PITFALLS AND SOLUTIONS
    # ============================================================================

    """
    PITFALLS TO AVOID:

    1. Input Length Issues (CRITICAL for SimPackets):
    - When using SimPackets: Length MUST match exactly what program expects
        * If program expects 12 bytes, set input_length = 12 (not 11, not 13!)
        * Wrong length = program never reaches success path or crashes
    - Finding correct length:
        * Look for: fgets(buf, 12, stdin), read(0, buf, 12), char password[12]
        * Try direct stdin first to discover length, then switch to SimPackets
        * Or iterate: for length in range(8, 20): try each
    - Direct stdin doesn't have this limitation (creates bytes on-demand)

    2. Missing Constraints:
    - Programs often expect specific input formats
    - Common constraints needed:
        * Printable ASCII: (byte >= 0x20) & (byte <= 0x7e)
        * Alphanumeric only: [a-zA-Z0-9]
        * Hex string: [0-9a-f]
        * Newline terminated: last byte = 0x0a
    - Add constraints BEFORE exploration starts

    3. State Explosion:
    - Too many paths = slow/OOM
    - Solutions:
        * Use more avoid addresses (especially loops)
        * Limit depth: sm.explore(find=target, n=1000)
        * Increase step timeout: sm.explore(find=target, step_func=lambda sm: sm.step(timeout=10))
        * Use veritesting: simulation_manager(s, veritesting=True)

    4. Library Functions:
    - angr may not handle complex libc functions well (rand, printf with %n, etc.)
    - Solutions:
        * Hook functions: p.hook(addr, angr.SIM_PROCEDURES['libc']['strlen']())
        * Use unicorn engine: add_options={angr.options.UNICORN}
        * Write custom simprocedures for problematic functions

    5. Architecture/Calling Convention:
    - Check binary arch
    - 32-bit vs 64-bit have different register usage
    - ARM/MIPS have different conventions than x86
    - Solution: Let angr auto-detect, or specify: angr.Project(binary, arch='i386')
    """

    if __name__ == "__main__":
        main()

  # 2) State & debugging (merges: stash_management + debugging_symbolic)
  state_debug: |
    ## State & stash debugging: move/merge/prune + quick constraint/var peek
    import angr
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    s = p.factory.entry_state()
    sm = p.factory.simulation_manager(s)

    # sample stash ops
    sm.step()
    sm.stash(filter_func=lambda st: b"error" in st.posix.dumps(1), from_stash='active', to_stash='errored')
    sm.move(from_stash='active', to_stash='found', filter_func=lambda st: st.addr == 0x401234) # TODO
    if len(sm.active) > 50: sm.merge(stash='active')
    sm.prune('active')

    class Debugger(angr.ExplorationTechnique):
        def __init__(self, breakpoints=None): super().__init__(); self.bps=set(breakpoints or [])
        def filter(self, simgr, st, **kw):
            if st.addr in self.bps:
                print(f"[BP] {hex(st.addr)}  depth={st.history.block_count}")
                cons = list(st.solver.constraints)
                for c in cons[-5:]: print("  ", c)
            return simgr.filter(st, **kw)
    sm.use_technique(Debugger([0x401234])) # TODO
    for i in range(5):
        print(f"step {i} active={len(sm.active)}"); sm.step()

  # 3) Exploration + performance (merges: exploration_techniques + performance_optimization + unicorn_acceleration)
  exploration_perf: |
    ## Exploration & perf: DFS/BFS, LoopSeer/Veritesting, Unicorn, state cap
    import angr
    from angr import exploration_techniques as ET, options as o
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    s = p.factory.entry_state(add_options={o.OPTIMIZE_IR, o.SIMPLIFY_CONSTRAINTS, o.SIMPLIFY_MEMORY_WRITES,
                                           o.SIMPLIFY_REGISTER_WRITES, o.FAST_MEMORY, o.FAST_REGISTERS,
                                           o.LAZY_SOLVES, o.UNICORN})
    sm = p.factory.simulation_manager(s)
    sm.use_technique(ET.DFS())
    sm.use_technique(ET.LengthLimiter(max_length=1000))
    sm.use_technique(ET.LoopSeer(bound=10))
    sm.use_technique(ET.Veritesting())
    class StateReducer(angr.ExplorationTechnique):
        def __init__(self, n=30): super().__init__(); self.n=n
        def step(self, sm, stash='active', **kw):
            if len(sm.active) > self.n:
                sm.active.sort(key=lambda st: getattr(st.history, "block_count", 0), reverse=True)
                del sm.active[self.n:]
                print(f"reduced to {self.n}")
            return sm.step(stash=stash, **kw)
    sm.use_technique(StateReducer(30))
    sm.step(n=100)

  # 4) Memory & init (merges: advanced_memory_model + bits of multi_arch)
  memory_init: |
    ## Memory/init: ZERO-fill, map scratch, bytewise constraints, per-arch touch
    import angr, claripy
    from archinfo import Endness
    from angr import options as o
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    s = p.factory.entry_state(add_options={o.ZERO_FILL_UNCONSTRAINED_MEMORY, o.ZERO_FILL_UNCONSTRAINED_REGISTERS,
                                           o.SYMBOLIC_INITIAL_VALUES, o.SIMPLIFY_MEMORY_WRITES, o.SIMPLIFY_REGISTER_WRITES})
    try: s.memory.map_region(0x70000000, 0x1000, permissions=7)
    except: pass
    pw_addr = 0x601000
    pw = claripy.BVS('password', 16*8)
    for i,b in enumerate(pw.chop(8)):
        s.solver.add(b >= 0x20, b <= 0x7e)
        if i<15: s.solver.add(b != pw.get_byte(i+1))
    s.memory.store(pw_addr, pw)
    s.memory.store(0x602000, b"MARKER")
    val = s.memory.load(0x602000, 6, endness=Endness.LE)
    print("read:", s.solver.eval(val, cast_to=bytes))

    # Per-arch demo write
    if p.arch.name == 'AMD64':
        s.regs.rdi = 0xdeadbeef
    elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
        s.regs.x0 = 0xdeadbeef
    elif p.arch.name == 'X86':
        s.regs.eax = 0xdeadbeef

  # 5) Input modeling (merges: argv_env_symbolic + symbolic_file + symbolic_registers_memory)
  input_modeling: |
    ## Input modeling: stdin/argv/env/file/regs/memory (ARM64/x64/x86)
    import angr, claripy
    p = angr.Project(r"{binary_path}", auto_load_libs=False)

    # stdin
    stdin = claripy.BVS("stdin", 32*8)
    # argv[1]
    argv1 = claripy.BVS("argv1", 16*8)
    # env
    envv = claripy.BVS("ENV_SECRET", 32*8)
    # file
    fsz = 64
    fcontent = claripy.BVS('file_content', fsz*8)
    symfile = angr.SimFile('input.txt', content=fcontent, size=fsz)

    s = p.factory.entry_state(args=[p.filename, argv1], env={"ENV_SECRET": envv}, fs={'input.txt': symfile}, stdin=stdin)

    for b in argv1.chop(8): s.solver.add(b >= 0x20, b <= 0x7e)
    for b in fcontent.chop(8): s.solver.add(b >= 0x20, b <= 0x7e)

    # Example: symbolize a "first argument register" / a general param register
    reg_in = claripy.BVS('reg_in', p.arch.bits)
    if p.arch.name == 'AMD64':
        s.regs.rdi = reg_in
    elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
        s.regs.x0 = reg_in
    elif p.arch.name == 'X86':
        s.regs.eax = reg_in

    # memory blob
    mem_addr = 0x601500
    mem_in = claripy.BVS('mem_in', 8*8)
    s.memory.store(mem_addr, mem_in)

    sm = p.factory.simulation_manager(s)
    sm.explore(find=lambda st: b"OK" in st.posix.dumps(1))
    if sm.found:
        st = sm.found[0]
        print("argv1:", st.solver.eval(argv1, cast_to=bytes))
        print("stdin:", st.posix.dumps(0))
        print("file:", st.solver.eval(fcontent, cast_to=bytes).rstrip(b'\\x00'))

  # 6) Function call analysis (from function_analysis_v2)
  function_call: |
    ## Function call: call_state with concrete/symbolic args, arch-aware returns
    import angr, claripy
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    func = 0x401000  # target function

    def ret_val(st):
        if p.arch.name == 'AMD64':   return st.regs.rax
        if p.arch.name == 'X86':     return st.regs.eax
        if p.arch.name.startswith('ARM') and p.arch.bits == 64: return st.regs.x0
        return None

    def run_call(func_addr, args):
        st = p.factory.call_state(func_addr, *args, ret_addr=0xDEADBEEF)
        sm = p.factory.simulation_manager(st); sm.run()
        outs = []
        for s in sm.deadended:
            if s.solver.satisfiable():
                rv = ret_val(s)
                outs.append({'return': s.solver.eval(rv) if rv is not None else None,
                             'stdout': s.posix.dumps(1), 'constraints': len(s.solver.constraints)})
        return outs

    a1, a2 = claripy.BVS('a1', 32), claripy.BVS('a2', 32)
    st = p.factory.call_state(func, a1, a2)
    st.solver.add(a1 > 0, a1 < 100, a2 != 0)
    sm = p.factory.simulation_manager(st); sm.run()
    for s in sm.deadended:
        if s.solver.satisfiable():
            rv = ret_val(s)
            print("f(", s.solver.eval(a1), ",", s.solver.eval(a2), ") ->", s.solver.eval(rv) if rv is not None else None)

    for r in run_call(func, [0x10, 0x20]): print("concrete ret:", hex(r['return']) if r['return'] is not None else None)

  # 7) Concolic (seeded) execution (from concolic_execution)
  concolic_seed: |
    ## Concolic: preconstrain stdin with a seed, removable later (arch-agnostic)
    import angr, claripy
    from angr.state_plugins.preconstrainer import SimStatePreconstrainer
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    seed = b"test_input_123"
    sym = claripy.BVS('input', len(seed)*8)
    s = p.factory.entry_state(stdin=sym)
    s.register_plugin('preconstrainer', SimStatePreconstrainer())
    s.preconstrainer.preconstrain(sym, seed)
    sm = p.factory.simulation_manager(s)
    while sm.active:
        sm.active.sort(key=lambda st: getattr(st.history, "block_count", 0), reverse=True)
        sm.step()
        for st in sm.active:
            if b"SUCCESS" in st.posix.dumps(1):
                try: st.preconstrainer.remove_preconstraints()
                except: pass
                print("found with seed; stdin:", st.posix.dumps(0)); sm.active=[]
                break

  # 8) API hooks & models (merges: api_modeling + hooks_and_stub)
  api_hooks: |
    ## API hooks & models: prefer libc simprocs; optional custom strcmp
    import angr
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    libc = angr.SIM_PROCEDURES['libc']
    if p.loader.find_symbol('strcmp'): p.hook_symbol('strcmp', libc['strcmp']())
    if p.loader.find_symbol('strlen'): p.hook_symbol('strlen', libc['strlen']())
    if p.loader.find_symbol('printf'): p.hook_symbol('printf', libc['printf']())
    if p.loader.find_symbol('malloc'): p.hook_symbol('malloc', libc['malloc']())
    if p.loader.find_symbol('free'):   p.hook_symbol('free',   libc['free']())

    class ConditionalHook(angr.SimProcedure):
        def run(self, arg):
            # Works across arches (bit-width comes from state.arch.bits)
            if self.state.solver.is_true(arg == 0x1337):
                return self.state.solver.BVV(1, self.state.arch.bits)
            return self.state.solver.BVV(0, self.state.arch.bits)
    # p.hook(0x401234, ConditionalHook())

  # 9) Vulnerability hunting (from vulnerability_detection)
  vuln_detection: |
    ## Vuln hunting: heuristic canary/RET control with big symbolic stdin (ARM64/x64/x86)
    import angr, claripy
    from angr import ExplorationTechnique
    p = angr.Project(r"{binary_path}", auto_load_libs=False)

    class OD(ExplorationTechnique):
        def __init__(self): super().__init__(); self.hits=[]
        def step_state(self, sm, st, **kw):
            try:
                # Return address check (arch-specific)
                if p.arch.name == 'AMD64':
                    ret = st.memory.load(st.regs.rsp, 8)
                elif p.arch.name == 'X86':
                    ret = st.memory.load(st.regs.esp, 4)
                elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
                    # On AArch64 return address is LR (x30); it may be spilled later.
                    ret = st.regs.lr
                else:
                    ret = None
                if ret is not None and getattr(ret,'symbolic',False):
                    self.hits.append(st.copy()); print("[ret] symbolic at", hex(st.addr))
            except: pass

            # Very rough canary probe (best-effort; layout dependent)
            try:
                if p.arch.name == 'AMD64':
                    canary = st.memory.load(st.regs.rbp - 8, 8);
                elif p.arch.name == 'X86':
                    canary = st.memory.load(st.regs.ebp - 4, 4);
                else:
                    canary = None
                if canary is not None and getattr(canary,'symbolic',False):
                    self.hits.append(st.copy()); print("[canary] symbolic near", hex(st.addr))
            except: pass
            return sm.step_state(st, **kw)

    s = p.factory.entry_state()
    big = claripy.BVS('in', 1000*8); s.posix.stdin.write(big); s.posix.stdin.seek(0)
    sm = p.factory.simulation_manager(s); od=OD(); sm.use_technique(od); sm.run(n=2000)
    print("potential overflows:", len(od.hits))

  # 10) Taint tracking (from taint_analysis)
  taint_tracking: |
    ## Taint: track stdin to dangerous sinks (system/execve/strcpy) across arches
    import angr, claripy
    from angr import options as o
    p = angr.Project(r"{binary_path}", auto_load_libs=False)

    def load_first_arg(st):
        # Return a BV representing arg0 at call site for each arch
        if p.arch.name == 'AMD64':
            return st.regs.rdi
        if p.arch.name.startswith('ARM') and p.arch.bits == 64:
            return st.regs.x0
        if p.arch.name == 'X86':
            # cdecl: [esp] return addr, [esp+4] arg0
            return st.memory.load(st.regs.esp + 4, st.arch.bytes)
        return None

    class TT(angr.ExplorationTechnique):
        def __init__(self): super().__init__(); self.sinks=[]
        def setup(self, sm):
            for st in sm.active:
                st.options.update({o.TRACK_MEMORY_ACTIONS,o.TRACK_REGISTER_ACTIONS,o.TRACK_JMP_ACTIONS,o.TRACK_CONSTRAINT_ACTIONS})
        def step_state(self, sm, st, **kw):
            succ = sm.step_state(st, **kw)
            for fn in ['system','execve','strcpy']:
                sym = p.loader.find_symbol(fn)
                if sym and st.addr == sym.rebased_addr:
                    a0 = load_first_arg(st)
                    if a0 is not None and getattr(a0,'symbolic',False):
                        print("TAINT SINK:", fn, "at", hex(st.addr)); self.sinks.append(st.copy())
            return succ

    s = p.factory.entry_state()
    tin = claripy.BVS('tainted', 100*8); s.posix.stdin.write(tin); s.posix.stdin.seek(0)
    sm = p.factory.simulation_manager(s); sm.use_technique(TT()); sm.run(n=1000)

  # 11) ROP chain (from rop_chain_generation)
  rop_chain: |
    ## ROP: gadgets, set regs, call system/execve via angrop (arch-aware)
    import angr, angrop
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    rop = p.analyses.ROP(); rop.find_gadgets()
    try:
        if p.arch.name == 'AMD64':
            g = rop.find_gadget(['pop rdi','ret'])
            if g: print("pop rdi; ret @", hex(g.addr))
        elif p.arch.name == 'X86':
            g = rop.find_gadget(['pop eax','ret'])
            if g: print("pop eax; ret @", hex(g.addr))
        elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
            # ARM64 ROP differs (no 'ret' gadgets like x86); angrop handles basics.
            pass
    except: pass
    chain = rop.chain()
    if p.arch.name == 'AMD64':
        chain.set_regs(rdi=0x601000, rsi=0x602000)
    elif p.arch.name == 'X86':
        chain.set_regs(eax=0x1337)
    elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
        chain.set_regs(x0=0x601000, x1=0x602000)

    sym = p.loader.find_symbol('system')
    if sym: chain.call(sym.rebased_addr, [0x601000] if p.arch.name != 'X86' else [0x601000])
    print("payload size:", len(chain.payload_bytes()))
    try:
        c2 = rop.build_execve(b'/bin/sh'); print("execve size:", len(c2.payload_bytes()))
    except Exception as e: print("execve build failed:", e)

  # 12) Deobfuscation helpers (from deobfuscation)
  deobfuscation: |
    ## Deobfuscation: skip junk NOPs (x86/x64 0x90, ARM64 0xD503201F) & hunt for "flag"
    import angr
    p = angr.Project(r"{binary_path}", auto_load_libs=False)
    class JunkSkip(angr.ExplorationTechnique):
        def step_state(self, sm, st, **kw):
            try:
                if p.arch.name in ('X86','AMD64'):
                    b = st.memory.load(st.addr, 1)
                    if st.solver.eval(b, cast_to=bytes) == b"\x90":  # x86/x64 NOP
                        st.regs.ip = st.addr + 1; return st
                elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
                    w = st.memory.load(st.addr, 4)
                    if st.solver.eval(w) == 0xD503201F:  # ARM64 NOP
                        st.regs.ip = st.addr + 4; return st
            except: pass
            return sm.step_state(st, **kw)
    s = p.factory.entry_state(); sm = p.factory.simulation_manager(s)
    sm.use_technique(JunkSkip())
    sm.explore(find=lambda st: b"flag" in st.posix.dumps(1))

  # 13) Protocol reversing (from protocol_reverse)
  protocol_reverse: |
    ## Protocol reversing: find recv/read handlers, infer fields, fuzz flips (ARM64/x64/x86)
    import angr, claripy
    from angr import options as o
    p = angr.Project(r"{binary_path}", auto_load_libs=False)

    def find_handlers():
        cfg = p.analyses.CFGFast(); H=set()
        for f in cfg.kb.functions.values():
            for b in f.blocks:
                try:
                    for insn in b.capstone.insns:
                        if 'call' in insn.mnemonic and any(api in insn.op_str for api in ['recv','read','recvfrom']):
                            H.add(f.addr); break
                except: pass
        return list(H)

    def _set_args(st, buf, sz):
        # Set (buf, size) as first two args on each arch
        if p.arch.name == 'AMD64':
            st.regs.rdi, st.regs.rsi = buf, sz
        elif p.arch.name.startswith('ARM') and p.arch.bits == 64:
            st.regs.x0, st.regs.x1 = buf, sz
        elif p.arch.name == 'X86':
            # cdecl: [esp] ret, [esp+4]=arg0, [esp+8]=arg1
            st.memory.store(st.regs.esp + 4, st.solver.BVV(buf, st.arch.bits))
            st.memory.store(st.regs.esp + 8, st.solver.BVV(sz,  st.arch.bits))

    def analyze(handler, pkt_sz=256):
        pkt = claripy.BVS('pkt', pkt_sz*8); buf=0x10000
        s = p.factory.blank_state(addr=handler)
        s.options.update({o.TRACK_MEMORY_ACTIONS,o.TRACK_REGISTER_ACTIONS,o.TRACK_JMP_ACTIONS,o.TRACK_CONSTRAINT_ACTIONS})
        s.memory.store(buf, pkt)
        _set_args(s, buf, pkt_sz)
        sm = p.factory.simulation_manager(s); acc=[]
        class Track(angr.ExplorationTechnique):
            def step_state(self, sm, st, **kw):
                try:
                    for a in st.history.actions:
                        if getattr(a,'type',None)=='mem' and getattr(a,'action',None)=='read':
                            addr = st.solver.eval(a.addr)
                            if buf <= addr < buf+pkt_sz:
                                sz = a.size//8 if hasattr(a,'size') else 1
                                acc.append((addr-buf, sz))
                except: pass
                return sm.step_state(st, **kw)
        sm.use_technique(Track()); sm.run(n=2000)
        summary={}
        for off, sz in acc: summary.setdefault(off, {'size':sz,'hits':0}); summary[off]['hits']+=1
        return summary

    H = find_handlers(); print("handlers:", len(H))
    if H:
        fields = analyze(H[0]);
        for off,info in sorted(fields.items()): print(f"offset {off}: size={info['size']} hits={info['hits']}")

  # 14) General analysis harness (from general_analysis)
  general_analysis: |
    ## General analysis: param-driven harness with timeouts & techniques
    import angr, claripy, time, logging
    logging.basicConfig(level=logging.INFO); log = logging.getLogger(__name__)
    def analyze_binary(binary_path, **kw):
        p = angr.Project(binary_path, auto_load_libs=False)
        params = dict(find_condition=None, avoid_conditions=None, symbolic_input_size=32, timeout=120,
                      use_unicorn=True, use_veritesting=True, max_states=100)
        params.update(kw)
        inp = claripy.BVS('input', params['symbolic_input_size']*8)
        opts = set();
        if params['use_unicorn']: opts.add(angr.options.UNICORN)
        s = p.factory.entry_state(stdin=inp, add_options=opts)
        for b in inp.chop(8): s.solver.add(b >= 0x20, b <= 0x7e)
        sm = p.factory.simulation_manager(s)
        if params['use_veritesting']: sm.use_technique(angr.exploration_techniques.Veritesting())
        class Limiter(angr.ExplorationTechnique):
            def step(self, sm, stash='active', **kw):
                if len(sm.active) > params['max_states']:
                    sm.active.sort(key=lambda st: -st.history.block_count); del sm.active[params['max_states']:]
                return sm.step(stash=stash, **kw)
        sm.use_technique(Limiter())
        t0=time.time()
        if params['find_condition']:
            sm.explore(find=params['find_condition'], avoid=params['avoid_conditions'])
        else:
            while sm.active and time.time()-t0 < params['timeout']: sm.step()
        res={'found':[], 'avoided':len(getattr(sm,'avoided',[])), 'deadended':len(sm.deadended),
             'active':len(sm.active), 'errored':len(sm.errored), 'time':time.time()-t0}
        for st in getattr(sm,'found',[]):
            if st.solver.satisfiable():
                res['found'].append({'addr':hex(st.addr),'stdin':st.posix.dumps(0),'stdout':st.posix.dumps(1),
                                     'stderr':st.posix.dumps(2),'constraints':len(st.solver.constraints),
                                     'history':st.history.block_count})
        return res

    if __name__ == "__main__":
        print(analyze_binary(r"{binary_path}", find_condition=0x401234, avoid_conditions=[0x401000], symbolic_input_size=32, timeout=60))

  # ========== From scratch ==========
  other: |
    import angr
    import claripy

    project = angr.Project(r"{binary_path}", auto_load_libs=False)
    # TODO: 根据具体需求补充分析流程

    state = project.factory.entry_state()
    sm = project.factory.simulation_manager(state)
    # TODO: 自定义分析逻辑
