# angr CTF 全关卡通关与可复现解题档案（00–17 + xx）

## 0. 概览

本仓库对 **angr_ctf** 全部主线关卡（00–17）及终极关 `xx_angr_segfault` 的解题过程进行了系统化整理，目标是：

- 提供**可复现的解题脚本**（按关卡编号组织）
- 提供**逐关说明文档**：包含二进制行为分析、关键地址/条件定位方式、angr 建模策略、常见坑位与稳定性处理
- 给读者（包括 LLM）一个清晰的“已完成内容范围 + 技能覆盖面 + 可迁移的方法论”视图

## 1. angr CTF 是什么

angr CTF 是围绕 **angr 符号执行**能力设计的训练题集合，难度从最基础的路径搜索逐步过渡到：

- 输入面建模：stdin/argv/寄存器/栈/堆/文件
- 语义替换：Hook / SimProcedure / 库函数建模（如 scanf）
- 路径爆炸治理：约束管理、路径剪枝、Veritesting 的适用边界
- 链接与装载：静态二进制与共享库分析（.so / .dylib）
- 漏洞利用原语建模：**Arbitrary Read / Write / Jump**
- 崩溃驱动分析：把 segfault 视为可利用的“分支线索”，而不是终点（xx）

## 2. 仓库结构（读者应如何浏览）

典型结构如下（实际以仓库为准）：

- `00_angr_find/ ... 17_angr_arbitrary_jump/`：每关题目目录（生成脚本/模板/说明）
- `xx_angr_segfault/`：终极关
- `binary/` 或 `dist/`：题目二进制与相关文件
- `solutions/`：可复现解题脚本（建议按 `solutions/<关卡>/solve.py` 组织）
- `docs/`（如有）：统一的补充说明（地址定位、调试策略、FAQ 等）

> 注：部分后期关卡会出现额外脚本（例如 taint_detect / exploit / avoid_segfault），用于演示“发现性审计→可控性确认→利用式建模”或“绕开崩溃分支”的工程化路线。 [oai_citation:3‡full_readme.md](sediment://file_00000000b81c71f7bd988082fc928aa9)  [oai_citation:4‡full_readme.md](sediment://file_00000000b81c71f7bd988082fc928aa9)

## 3. 快速复现（以单关为单位）

### 3.1 环境要求（最小集合）
- Python 3.x
- angr（及其依赖）
- 推荐：radare2/objdump（用于定位字符串引用、函数入口、基本块地址）

### 3.2 安装
```bash
python3 -m venv angr_ctf_env
source angr_ctf_env/bin/activate
pip install --upgrade pip
pip install angr

3.3 运行某一关

python3 solutions/<关卡目录>/solve.py <二进制路径>

3.4 地址漂移说明

如果脚本中使用了硬编码地址（find/avoid/Hook 点），则在以下情况需要重新定位并更新：
	•	重新编译 / 更换 seed
	•	不同平台/不同构建产物导致基址与偏移变化

4. 关卡能力图谱（按主题分层）

4.1 入门：路径搜索与成功判据（00–02）
	•	find / avoid 的基本闭环
	•	使用谓词（lambda）以“状态特征”作为成功/失败判据（如 stdout 包含特定字符串）

4.2 基础进阶：精细数据建模（03–08）

覆盖寄存器、栈、静态内存、堆、文件等输入面的符号化与约束组织。

4.3 实战技巧：语义替换与性能治理（09–12）
	•	Hook 与“替换语义”以加速探索
	•	自定义 SimProcedure（典型：scanf/库函数）
	•	Veritesting 的可用边界与替代方案（必要时用“定点替换 + 强约束”保证稳定性）

4.4 系统与链接：静态/共享库（13–14）
	•	静态链接场景下的库函数缺失与替代策略
	•	共享库分析：基址一致性、从导出函数入口 call_state 起跑，而非依赖 main/_start

共享库关卡强调“基址一致、参数正确、约束合理”，可稳定单独执行 .so 中的 validate 并求解固定长度口令。 ￼

4.5 内存与控制流：漏洞利用原语建模（15–17）
	•	15：任意读（从“已知利用点快速构造”到“在 puts 入口做可控性判定/发现性审计”两路线） ￼
	•	16：任意写（地址具体化策略与写入目标约束）
	•	17：任意跳转（既支持利用式 Hook 快速达成，也覆盖 Unconstrained State 路线；并总结了 Hook 中重算 CFG 破坏控制流的陷阱与规避原则） ￼  ￼

4.6 特殊关：崩溃驱动求解（xx）

终极关不以“出现 Try again 字符串”作为成功判据，而是以“到达安全地址/安全落点”为目标，并要求：
	•	Hook scanf（多输出参数）
	•	处理 %20s 的 \x00 终止符
	•	写入整数时显式指定端序
	•	对易崩溃分支做 avoid，或强约束进入安全分支

上述要点与样例脚本在笔记中有明确总结。 ￼  ￼

5. 完成全部挑战后达到的状态（能力画像）

完成 00–17 + xx 并形成可复现脚本与逐关文档后，意味着已具备以下可验证能力：

5.1 angr 核心工作流（可落地）
	•	熟练构建 Project / State / Simgr，并以 find/avoid/谓词条件组织探索
	•	能从成功状态中稳定提取输入（stdin/argv/内存/寄存器）

5.2 输入面与内存建模（可迁移）
	•	能将符号输入放置在“程序真正消费的位置”：寄存器、栈帧、堆对象、文件内容、结构体字段与指针指向区域
	•	能处理端序、空终止、长度边界等“工程细节”，避免求解不稳定

5.3 路径爆炸治理与性能策略（可解释）
	•	能用 avoid/强约束/分阶段策略收敛搜索空间
	•	能通过 Hook / SimProcedure 替换复杂或无关语义，降低状态数量
	•	理解 Veritesting 的适用范围，并能在不稳定时采用替代策略

5.4 链接装载与入口选择（可扩展到真实目标）
	•	能处理静态链接二进制（库函数建模/替代）
	•	能分析共享库：基址、导出符号、以 call_state 从库函数入口起跑（而非依赖 main）

5.5 漏洞利用原语建模（可组合）
	•	能用 angr 验证与构造 Arbitrary Read / Write / Jump 的可满足性
	•	能在控制流层面处理 Unconstrained State，并将其约束落地为可执行落点

5.6 崩溃驱动调试（可用于“硬目标”）
	•	能识别“崩溃分支”的触发条件并将其转化为约束/avoid 策略
	•	能在缺少稳定成功字符串时，改用“到达安全地址/安全收尾”作为成功判据

6. 参考与延伸
	•	angr 官方文档：https://docs.angr.io/
	•	angr GitHub：https://github.com/angr/angr
	•	angr_ctf 原仓库：https://github.com/jakespringer/angr_ctf

⸻

附录：常见问题（摘选）

A. 为什么同样脚本在不同机器上失效？

常见原因是地址漂移（构建产物不同/seed 不同/平台不同），需要按 r2/objdump 重新定位 find/avoid/hook 点。

B. 为什么需要 Hook scanf？

多输出参数与写入端序/空终止符等细节若不建模，会导致输入不可控或状态爆炸；在 xx 与部分后期关卡尤为关键。 ￼
